@startuml

class Variable {
    - id : int
    - domain : set<int>
    - domainDelta : stack<int>
    + reduceDomain(value : int) : void
    + restoreLastDomain() : void
    + getDomain() : set<int>& {query}
    + getId() : int {query}
}

abstract class IConstraint {
    + isSatisfied(assignments : unordered_map<int, int>&) : bool {query}
    + getScope() : vector<Variable*>& {query}
}

class NoRepeatsConstraint {
    + isSatisfied(assignments : unordered_map<int, int>&) : bool {query}
    + getScope() : vector<Variable*>& {query}
}

class CSP {
    - variables : vector<Variable>
    - constraints : vector<unique_ptr<IConstraint>>
    + CSP(const CSP&) = delete
    + operator=(const CSP&) : CSP& = delete
    + CSP(CSP&&) = delete
    + operator=(CSP&&) : CSP& = delete
    + addConstraint(constraint : unique_ptr<IConstraint>&&) : void
    + addVariable(var : Variable) : void
    + getConstraints() : vector<unique_ptr<IConstraint>>& {query}
    + getVariables() : vector<Variable>& {query}
    + getUnassignedVariables(assignments : unordered_map<int, int>&) : vector<Variable*> {query}
}

class Solver {
    - csp : CSP&
    - variableHeuristic : unique_ptr<IVariableHeuristic>
    - valueHeuristic : unique_ptr<IValueHeuristic>
    - propagator : unique_ptr<IPropagator>
    - checkConstraint(assignments : unordered_map<int, int>&) : bool {query}
    - propagate() : void
    - orderValues(var : Variable&, assignments : unordered_map<int, int>&)) : set<int> {query}
    - chooseNextVariable(assignments : unordered_map<int, int>&) : Variable* {query}
    + setVariableHeuristic(variableHeuristic : unique_ptr<IVariableHeuristic>) : void
    + setValueHeuristic(valueHeuristic : unique_ptr<IValueHeuristic>) : void
    + setPropagator(propagator : unique_ptr<IPropagation>) : void
    + backtrackingSearch(unordered_map<int, int> assignments) : bool
}

abstract class IVariableHeuristic {
    + chooseVariable(csp : CSP&, assignments : unordered_map<int, int>&) : Variable* {query}
}

abstract class IValueHeuristic {
    + orderValues(csp : CSP&, var : Variable&, assignments : unordered_map<int, int>&) : const set<int> {query}
}

abstract class IPropagator {
    + propagate() : void
}

class MRVHeuristic {
    + chooseVariable(csp : CSP&, assignments : unordered_map<int, int>&) : Variable* {query}
}


CSP "1..*" --> "1..*" Variable : contains
CSP "1..*" --> "1..*" IConstraint : contains
Solver --> CSP : uses
IConstraint --> Variable : references

Solver --> IVariableHeuristic : uses (delegation)
Solver --> IValueHeuristic : uses (delegation)
Solver --> IPropagator : uses (delegation)

MRVHeuristic -|> IVariableHeuristic
NoRepeatsConstraint -|> IConstraint

@enduml
